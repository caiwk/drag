// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: drummer.proto

/*
	Package drummerpb is a generated protocol buffer package.

	Package drummerpb contains definition of internal structs and messages used
	by the optional Drummer component. Your dragonboat application only needs to
	import this package when you choose to let drummer to manage your distributed
	nodehost instances.

	It is generated from these files:
		drummer.proto

	It has these top-level messages:
		Regions
		Cluster
		ClusterCollection
		KV
		Change
		ChangeResponse
		Update
		LookupRequest
		LookupResponse
		Request
		ClusterStateRequest
		ClusterState
		ClusterInfo
		LogInfo
		ClusterStates
		NodeHostInfo
		NodeHostCollection
		ConfigChangeIndexList
		DeploymentInfo
		Empty
		NodeHostRequest
		NodeHostRequestCollection
		DrummerConfigRequest
		Config
*/
package drummerpb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Change_Type int32

const (
	Change_CREATE Change_Type = 0
)

var Change_Type_name = map[int32]string{
	0: "CREATE",
}
var Change_Type_value = map[string]int32{
	"CREATE": 0,
}

func (x Change_Type) Enum() *Change_Type {
	p := new(Change_Type)
	*p = x
	return p
}
func (x Change_Type) String() string {
	return proto.EnumName(Change_Type_name, int32(x))
}
func (x *Change_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Change_Type_value, data, "Change_Type")
	if err != nil {
		return err
	}
	*x = Change_Type(value)
	return nil
}
func (Change_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{4, 0} }

type ChangeResponse_Code int32

const (
	ChangeResponse_OK                ChangeResponse_Code = 0
	ChangeResponse_CLUSTER_NOT_FOUND ChangeResponse_Code = 1
	ChangeResponse_CONFLICT_FOUND    ChangeResponse_Code = 2
	ChangeResponse_UNKNOWN_RETRY     ChangeResponse_Code = 3
	ChangeResponse_CLUSTER_EXIST     ChangeResponse_Code = 4
	ChangeResponse_BOOTSTRAPPED      ChangeResponse_Code = 5
	ChangeResponse_REGIONS_SET       ChangeResponse_Code = 6
)

var ChangeResponse_Code_name = map[int32]string{
	0: "OK",
	1: "CLUSTER_NOT_FOUND",
	2: "CONFLICT_FOUND",
	3: "UNKNOWN_RETRY",
	4: "CLUSTER_EXIST",
	5: "BOOTSTRAPPED",
	6: "REGIONS_SET",
}
var ChangeResponse_Code_value = map[string]int32{
	"OK":                0,
	"CLUSTER_NOT_FOUND": 1,
	"CONFLICT_FOUND":    2,
	"UNKNOWN_RETRY":     3,
	"CLUSTER_EXIST":     4,
	"BOOTSTRAPPED":      5,
	"REGIONS_SET":       6,
}

func (x ChangeResponse_Code) Enum() *ChangeResponse_Code {
	p := new(ChangeResponse_Code)
	*p = x
	return p
}
func (x ChangeResponse_Code) String() string {
	return proto.EnumName(ChangeResponse_Code_name, int32(x))
}
func (x *ChangeResponse_Code) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ChangeResponse_Code_value, data, "ChangeResponse_Code")
	if err != nil {
		return err
	}
	*x = ChangeResponse_Code(value)
	return nil
}
func (ChangeResponse_Code) EnumDescriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{5, 0} }

type Update_Type int32

const (
	Update_CLUSTER       Update_Type = 0
	Update_KV            Update_Type = 1
	Update_TICK          Update_Type = 2
	Update_NODEHOST_INFO Update_Type = 3
	Update_REQUESTS      Update_Type = 4
)

var Update_Type_name = map[int32]string{
	0: "CLUSTER",
	1: "KV",
	2: "TICK",
	3: "NODEHOST_INFO",
	4: "REQUESTS",
}
var Update_Type_value = map[string]int32{
	"CLUSTER":       0,
	"KV":            1,
	"TICK":          2,
	"NODEHOST_INFO": 3,
	"REQUESTS":      4,
}

func (x Update_Type) Enum() *Update_Type {
	p := new(Update_Type)
	*p = x
	return p
}
func (x Update_Type) String() string {
	return proto.EnumName(Update_Type_name, int32(x))
}
func (x *Update_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Update_Type_value, data, "Update_Type")
	if err != nil {
		return err
	}
	*x = Update_Type(value)
	return nil
}
func (Update_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{6, 0} }

type LookupRequest_Type int32

const (
	LookupRequest_CLUSTER           LookupRequest_Type = 0
	LookupRequest_KV                LookupRequest_Type = 1
	LookupRequest_SCHEDULER_CONTEXT LookupRequest_Type = 3
	LookupRequest_REQUESTS          LookupRequest_Type = 4
	LookupRequest_CLUSTER_STATES    LookupRequest_Type = 5
)

var LookupRequest_Type_name = map[int32]string{
	0: "CLUSTER",
	1: "KV",
	3: "SCHEDULER_CONTEXT",
	4: "REQUESTS",
	5: "CLUSTER_STATES",
}
var LookupRequest_Type_value = map[string]int32{
	"CLUSTER":           0,
	"KV":                1,
	"SCHEDULER_CONTEXT": 3,
	"REQUESTS":          4,
	"CLUSTER_STATES":    5,
}

func (x LookupRequest_Type) Enum() *LookupRequest_Type {
	p := new(LookupRequest_Type)
	*p = x
	return p
}
func (x LookupRequest_Type) String() string {
	return proto.EnumName(LookupRequest_Type_name, int32(x))
}
func (x *LookupRequest_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LookupRequest_Type_value, data, "LookupRequest_Type")
	if err != nil {
		return err
	}
	*x = LookupRequest_Type(value)
	return nil
}
func (LookupRequest_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{7, 0} }

type LookupResponse_Code int32

const (
	LookupResponse_OK                LookupResponse_Code = 0
	LookupResponse_CLUSTER_NOT_FOUND LookupResponse_Code = 1
)

var LookupResponse_Code_name = map[int32]string{
	0: "OK",
	1: "CLUSTER_NOT_FOUND",
}
var LookupResponse_Code_value = map[string]int32{
	"OK":                0,
	"CLUSTER_NOT_FOUND": 1,
}

func (x LookupResponse_Code) Enum() *LookupResponse_Code {
	p := new(LookupResponse_Code)
	*p = x
	return p
}
func (x LookupResponse_Code) String() string {
	return proto.EnumName(LookupResponse_Code_name, int32(x))
}
func (x *LookupResponse_Code) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LookupResponse_Code_value, data, "LookupResponse_Code")
	if err != nil {
		return err
	}
	*x = LookupResponse_Code(value)
	return nil
}
func (LookupResponse_Code) EnumDescriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{8, 0} }

type Request_Type int32

const (
	Request_CREATE Request_Type = 0
	Request_DELETE Request_Type = 1
	Request_ADD    Request_Type = 2
	Request_KILL   Request_Type = 3
)

var Request_Type_name = map[int32]string{
	0: "CREATE",
	1: "DELETE",
	2: "ADD",
	3: "KILL",
}
var Request_Type_value = map[string]int32{
	"CREATE": 0,
	"DELETE": 1,
	"ADD":    2,
	"KILL":   3,
}

func (x Request_Type) Enum() *Request_Type {
	p := new(Request_Type)
	*p = x
	return p
}
func (x Request_Type) String() string {
	return proto.EnumName(Request_Type_name, int32(x))
}
func (x *Request_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Request_Type_value, data, "Request_Type")
	if err != nil {
		return err
	}
	*x = Request_Type(value)
	return nil
}
func (Request_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{9, 0} }

type ClusterState_State int32

const (
	ClusterState_OK          ClusterState_State = 0
	ClusterState_UNAVAILABLE ClusterState_State = 1
)

var ClusterState_State_name = map[int32]string{
	0: "OK",
	1: "UNAVAILABLE",
}
var ClusterState_State_value = map[string]int32{
	"OK":          0,
	"UNAVAILABLE": 1,
}

func (x ClusterState_State) Enum() *ClusterState_State {
	p := new(ClusterState_State)
	*p = x
	return p
}
func (x ClusterState_State) String() string {
	return proto.EnumName(ClusterState_State_name, int32(x))
}
func (x *ClusterState_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ClusterState_State_value, data, "ClusterState_State")
	if err != nil {
		return err
	}
	*x = ClusterState_State(value)
	return nil
}
func (ClusterState_State) EnumDescriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{11, 0} }

// Regions is the message used to describe the requested region.
type Regions struct {
	Region []string `protobuf:"bytes,1,rep,name=region" json:"region,omitempty"`
	Count  []uint64 `protobuf:"varint,2,rep,name=count" json:"count,omitempty"`
}

func (m *Regions) Reset()                    { *m = Regions{} }
func (m *Regions) String() string            { return proto.CompactTextString(m) }
func (*Regions) ProtoMessage()               {}
func (*Regions) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{0} }

func (m *Regions) GetRegion() []string {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *Regions) GetCount() []uint64 {
	if m != nil {
		return m.Count
	}
	return nil
}

// Cluster is the message used to describe a defined raft cluster.
type Cluster struct {
	Members   []uint64 `protobuf:"varint,1,rep,name=members" json:"members,omitempty"`
	ClusterId uint64   `protobuf:"varint,2,opt,name=cluster_id,json=clusterId" json:"cluster_id"`
	AppName   string   `protobuf:"bytes,3,opt,name=app_name,json=appName" json:"app_name"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{1} }

func (m *Cluster) GetMembers() []uint64 {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *Cluster) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *Cluster) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

// ClusterCollection is the message used to describe a list of clusters.
type ClusterCollection struct {
	Clusters []*Cluster `protobuf:"bytes,1,rep,name=clusters" json:"clusters,omitempty"`
}

func (m *ClusterCollection) Reset()                    { *m = ClusterCollection{} }
func (m *ClusterCollection) String() string            { return proto.CompactTextString(m) }
func (*ClusterCollection) ProtoMessage()               {}
func (*ClusterCollection) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{2} }

func (m *ClusterCollection) GetClusters() []*Cluster {
	if m != nil {
		return m.Clusters
	}
	return nil
}

// KV is the message used to describe a Key-Value request.
type KV struct {
	Key           string `protobuf:"bytes,1,req,name=key" json:"key"`
	Value         string `protobuf:"bytes,2,req,name=value" json:"value"`
	InstanceId    uint64 `protobuf:"varint,3,opt,name=instance_id,json=instanceId" json:"instance_id"`
	Tick          uint64 `protobuf:"varint,4,opt,name=tick" json:"tick"`
	OldInstanceId uint64 `protobuf:"varint,5,opt,name=old_instance_id,json=oldInstanceId" json:"old_instance_id"`
	Finalized     bool   `protobuf:"varint,6,opt,name=finalized" json:"finalized"`
}

func (m *KV) Reset()                    { *m = KV{} }
func (m *KV) String() string            { return proto.CompactTextString(m) }
func (*KV) ProtoMessage()               {}
func (*KV) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{3} }

func (m *KV) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KV) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *KV) GetInstanceId() uint64 {
	if m != nil {
		return m.InstanceId
	}
	return 0
}

func (m *KV) GetTick() uint64 {
	if m != nil {
		return m.Tick
	}
	return 0
}

func (m *KV) GetOldInstanceId() uint64 {
	if m != nil {
		return m.OldInstanceId
	}
	return 0
}

func (m *KV) GetFinalized() bool {
	if m != nil {
		return m.Finalized
	}
	return false
}

// Change is the message used to define new raft clusters in Drummer.
type Change struct {
	Type      Change_Type `protobuf:"varint,1,req,name=type,enum=drummerpb.Change_Type" json:"type"`
	ClusterId uint64      `protobuf:"varint,2,req,name=cluster_id,json=clusterId" json:"cluster_id"`
	Members   []uint64    `protobuf:"varint,3,rep,name=members" json:"members,omitempty"`
	AppName   string      `protobuf:"bytes,4,opt,name=app_name,json=appName" json:"app_name"`
}

func (m *Change) Reset()                    { *m = Change{} }
func (m *Change) String() string            { return proto.CompactTextString(m) }
func (*Change) ProtoMessage()               {}
func (*Change) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{4} }

func (m *Change) GetType() Change_Type {
	if m != nil {
		return m.Type
	}
	return Change_CREATE
}

func (m *Change) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *Change) GetMembers() []uint64 {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *Change) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

// ChangeResponse is the message issued by Drummer in response to Change
// messages.
type ChangeResponse struct {
	Code ChangeResponse_Code `protobuf:"varint,1,req,name=code,enum=drummerpb.ChangeResponse_Code" json:"code"`
}

func (m *ChangeResponse) Reset()                    { *m = ChangeResponse{} }
func (m *ChangeResponse) String() string            { return proto.CompactTextString(m) }
func (*ChangeResponse) ProtoMessage()               {}
func (*ChangeResponse) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{5} }

func (m *ChangeResponse) GetCode() ChangeResponse_Code {
	if m != nil {
		return m.Code
	}
	return ChangeResponse_OK
}

// Update is the message used for updating DrummerDB. DrummerDB is used to
// store raft cluster definitions and Drummer key-value pairs.
type Update struct {
	Change       Change                    `protobuf:"bytes,1,opt,name=change" json:"change"`
	Type         Update_Type               `protobuf:"varint,2,req,name=type,enum=drummerpb.Update_Type" json:"type"`
	KvUpdate     KV                        `protobuf:"bytes,3,opt,name=kv_update,json=kvUpdate" json:"kv_update"`
	NodehostInfo NodeHostInfo              `protobuf:"bytes,4,opt,name=nodehost_info,json=nodehostInfo" json:"nodehost_info"`
	Requests     NodeHostRequestCollection `protobuf:"bytes,5,opt,name=requests" json:"requests"`
}

func (m *Update) Reset()                    { *m = Update{} }
func (m *Update) String() string            { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()               {}
func (*Update) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{6} }

func (m *Update) GetChange() Change {
	if m != nil {
		return m.Change
	}
	return Change{}
}

func (m *Update) GetType() Update_Type {
	if m != nil {
		return m.Type
	}
	return Update_CLUSTER
}

func (m *Update) GetKvUpdate() KV {
	if m != nil {
		return m.KvUpdate
	}
	return KV{}
}

func (m *Update) GetNodehostInfo() NodeHostInfo {
	if m != nil {
		return m.NodehostInfo
	}
	return NodeHostInfo{}
}

func (m *Update) GetRequests() NodeHostRequestCollection {
	if m != nil {
		return m.Requests
	}
	return NodeHostRequestCollection{}
}

// LookupRequest is the lookup request message.
type LookupRequest struct {
	Type          LookupRequest_Type  `protobuf:"varint,1,req,name=type,enum=drummerpb.LookupRequest_Type" json:"type"`
	ClusterIdList []uint64            `protobuf:"varint,2,rep,name=cluster_id_list,json=clusterIdList" json:"cluster_id_list,omitempty"`
	KvLookup      KV                  `protobuf:"bytes,3,opt,name=kv_lookup,json=kvLookup" json:"kv_lookup"`
	RequestsId    uint64              `protobuf:"varint,4,opt,name=requests_id,json=requestsId" json:"requests_id"`
	Address       string              `protobuf:"bytes,5,opt,name=address" json:"address"`
	Stats         ClusterStateRequest `protobuf:"bytes,6,opt,name=stats" json:"stats"`
}

func (m *LookupRequest) Reset()                    { *m = LookupRequest{} }
func (m *LookupRequest) String() string            { return proto.CompactTextString(m) }
func (*LookupRequest) ProtoMessage()               {}
func (*LookupRequest) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{7} }

func (m *LookupRequest) GetType() LookupRequest_Type {
	if m != nil {
		return m.Type
	}
	return LookupRequest_CLUSTER
}

func (m *LookupRequest) GetClusterIdList() []uint64 {
	if m != nil {
		return m.ClusterIdList
	}
	return nil
}

func (m *LookupRequest) GetKvLookup() KV {
	if m != nil {
		return m.KvLookup
	}
	return KV{}
}

func (m *LookupRequest) GetRequestsId() uint64 {
	if m != nil {
		return m.RequestsId
	}
	return 0
}

func (m *LookupRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *LookupRequest) GetStats() ClusterStateRequest {
	if m != nil {
		return m.Stats
	}
	return ClusterStateRequest{}
}

// LookupResponse is the lookup response message.
type LookupResponse struct {
	Code     LookupResponse_Code       `protobuf:"varint,1,opt,name=code,enum=drummerpb.LookupResponse_Code" json:"code"`
	Clusters []*Cluster                `protobuf:"bytes,2,rep,name=clusters" json:"clusters,omitempty"`
	KvResult KV                        `protobuf:"bytes,3,opt,name=kv_result,json=kvResult" json:"kv_result"`
	Requests NodeHostRequestCollection `protobuf:"bytes,4,opt,name=requests" json:"requests"`
}

func (m *LookupResponse) Reset()                    { *m = LookupResponse{} }
func (m *LookupResponse) String() string            { return proto.CompactTextString(m) }
func (*LookupResponse) ProtoMessage()               {}
func (*LookupResponse) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{8} }

func (m *LookupResponse) GetCode() LookupResponse_Code {
	if m != nil {
		return m.Code
	}
	return LookupResponse_OK
}

func (m *LookupResponse) GetClusters() []*Cluster {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *LookupResponse) GetKvResult() KV {
	if m != nil {
		return m.KvResult
	}
	return KV{}
}

func (m *LookupResponse) GetRequests() NodeHostRequestCollection {
	if m != nil {
		return m.Requests
	}
	return NodeHostRequestCollection{}
}

// Request is the Request sent to Nodehosts.
type Request struct {
	Type         Request_Type `protobuf:"varint,1,req,name=type,enum=drummerpb.Request_Type" json:"type"`
	ClusterId    uint64       `protobuf:"varint,2,req,name=cluster_id,json=clusterId" json:"cluster_id"`
	Members      []uint64     `protobuf:"varint,3,rep,name=members" json:"members,omitempty"`
	AppName      string       `protobuf:"bytes,4,opt,name=app_name,json=appName" json:"app_name"`
	ConfChangeId uint64       `protobuf:"varint,5,opt,name=conf_change_id,json=confChangeId" json:"conf_change_id"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{9} }

func (m *Request) GetType() Request_Type {
	if m != nil {
		return m.Type
	}
	return Request_CREATE
}

func (m *Request) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *Request) GetMembers() []uint64 {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *Request) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *Request) GetConfChangeId() uint64 {
	if m != nil {
		return m.ConfChangeId
	}
	return 0
}

// ClusterStateRequest is the message used to send a list of cluster id values
// to Drummer for requesting cluster state details.
type ClusterStateRequest struct {
	ClusterIdList []uint64 `protobuf:"varint,1,rep,name=cluster_id_list,json=clusterIdList" json:"cluster_id_list,omitempty"`
}

func (m *ClusterStateRequest) Reset()                    { *m = ClusterStateRequest{} }
func (m *ClusterStateRequest) String() string            { return proto.CompactTextString(m) }
func (*ClusterStateRequest) ProtoMessage()               {}
func (*ClusterStateRequest) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{10} }

func (m *ClusterStateRequest) GetClusterIdList() []uint64 {
	if m != nil {
		return m.ClusterIdList
	}
	return nil
}

// ClusterState is the message used to provide cluster state to clients.
type ClusterState struct {
	ClusterId         uint64             `protobuf:"varint,1,req,name=cluster_id,json=clusterId" json:"cluster_id"`
	LeaderNodeId      uint64             `protobuf:"varint,2,opt,name=leader_node_id,json=leaderNodeId" json:"leader_node_id"`
	Nodes             map[uint64]string  `protobuf:"bytes,3,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	RPCAddresses      map[uint64]string  `protobuf:"bytes,4,rep,name=RPCAddresses" json:"RPCAddresses,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	State             ClusterState_State `protobuf:"varint,5,opt,name=state,enum=drummerpb.ClusterState_State" json:"state"`
	ConfigChangeIndex uint64             `protobuf:"varint,6,opt,name=config_change_index,json=configChangeIndex" json:"config_change_index"`
}

func (m *ClusterState) Reset()                    { *m = ClusterState{} }
func (m *ClusterState) String() string            { return proto.CompactTextString(m) }
func (*ClusterState) ProtoMessage()               {}
func (*ClusterState) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{11} }

func (m *ClusterState) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *ClusterState) GetLeaderNodeId() uint64 {
	if m != nil {
		return m.LeaderNodeId
	}
	return 0
}

func (m *ClusterState) GetNodes() map[uint64]string {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *ClusterState) GetRPCAddresses() map[uint64]string {
	if m != nil {
		return m.RPCAddresses
	}
	return nil
}

func (m *ClusterState) GetState() ClusterState_State {
	if m != nil {
		return m.State
	}
	return ClusterState_OK
}

func (m *ClusterState) GetConfigChangeIndex() uint64 {
	if m != nil {
		return m.ConfigChangeIndex
	}
	return 0
}

type ClusterInfo struct {
	ClusterId         uint64            `protobuf:"varint,1,req,name=cluster_id,json=clusterId" json:"cluster_id"`
	NodeId            uint64            `protobuf:"varint,2,req,name=node_id,json=nodeId" json:"node_id"`
	IsLeader          bool              `protobuf:"varint,3,opt,name=is_leader,json=isLeader" json:"is_leader"`
	Nodes             map[uint64]string `protobuf:"bytes,4,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ConfigChangeIndex uint64            `protobuf:"varint,5,opt,name=config_change_index,json=configChangeIndex" json:"config_change_index"`
	Incomplete        bool              `protobuf:"varint,6,opt,name=incomplete" json:"incomplete"`
	Pending           bool              `protobuf:"varint,7,opt,name=pending" json:"pending"`
}

func (m *ClusterInfo) Reset()                    { *m = ClusterInfo{} }
func (m *ClusterInfo) String() string            { return proto.CompactTextString(m) }
func (*ClusterInfo) ProtoMessage()               {}
func (*ClusterInfo) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{12} }

func (m *ClusterInfo) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *ClusterInfo) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *ClusterInfo) GetIsLeader() bool {
	if m != nil {
		return m.IsLeader
	}
	return false
}

func (m *ClusterInfo) GetNodes() map[uint64]string {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *ClusterInfo) GetConfigChangeIndex() uint64 {
	if m != nil {
		return m.ConfigChangeIndex
	}
	return 0
}

func (m *ClusterInfo) GetIncomplete() bool {
	if m != nil {
		return m.Incomplete
	}
	return false
}

func (m *ClusterInfo) GetPending() bool {
	if m != nil {
		return m.Pending
	}
	return false
}

// LogInfo is the message used by nodehost to notify Drummer that it has
// raft log that belongs to the specified raft cluster.
type LogInfo struct {
	ClusterId uint64 `protobuf:"varint,1,req,name=cluster_id,json=clusterId" json:"cluster_id"`
	NodeId    uint64 `protobuf:"varint,2,req,name=node_id,json=nodeId" json:"node_id"`
}

func (m *LogInfo) Reset()                    { *m = LogInfo{} }
func (m *LogInfo) String() string            { return proto.CompactTextString(m) }
func (*LogInfo) ProtoMessage()               {}
func (*LogInfo) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{13} }

func (m *LogInfo) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *LogInfo) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

// ClusterStates contains a list of ClusterState messages.
type ClusterStates struct {
	Collection []*ClusterState `protobuf:"bytes,1,rep,name=collection" json:"collection,omitempty"`
}

func (m *ClusterStates) Reset()                    { *m = ClusterStates{} }
func (m *ClusterStates) String() string            { return proto.CompactTextString(m) }
func (*ClusterStates) ProtoMessage()               {}
func (*ClusterStates) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{14} }

func (m *ClusterStates) GetCollection() []*ClusterState {
	if m != nil {
		return m.Collection
	}
	return nil
}

// NodeHostInfo is the message used by nodehost to report its state, including
// managed raft clusters and local persistent logs to Drummer.
type NodeHostInfo struct {
	RaftAddress      string        `protobuf:"bytes,1,req,name=raft_address,json=raftAddress" json:"raft_address"`
	ClusterInfo      []ClusterInfo `protobuf:"bytes,2,rep,name=cluster_info,json=clusterInfo" json:"cluster_info"`
	ClusterIdList    []uint64      `protobuf:"varint,3,rep,name=cluster_id_list,json=clusterIdList" json:"cluster_id_list,omitempty"`
	LastTick         uint64        `protobuf:"varint,4,opt,name=last_tick,json=lastTick" json:"last_tick"`
	PlogInfoIncluded bool          `protobuf:"varint,5,opt,name=plog_info_included,json=plogInfoIncluded" json:"plog_info_included"`
	PlogInfo         []LogInfo     `protobuf:"bytes,6,rep,name=plog_info,json=plogInfo" json:"plog_info"`
	Region           string        `protobuf:"bytes,7,opt,name=region" json:"region"`
	RPCAddress       string        `protobuf:"bytes,8,opt,name=RPCAddress" json:"RPCAddress"`
}

func (m *NodeHostInfo) Reset()                    { *m = NodeHostInfo{} }
func (m *NodeHostInfo) String() string            { return proto.CompactTextString(m) }
func (*NodeHostInfo) ProtoMessage()               {}
func (*NodeHostInfo) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{15} }

func (m *NodeHostInfo) GetRaftAddress() string {
	if m != nil {
		return m.RaftAddress
	}
	return ""
}

func (m *NodeHostInfo) GetClusterInfo() []ClusterInfo {
	if m != nil {
		return m.ClusterInfo
	}
	return nil
}

func (m *NodeHostInfo) GetClusterIdList() []uint64 {
	if m != nil {
		return m.ClusterIdList
	}
	return nil
}

func (m *NodeHostInfo) GetLastTick() uint64 {
	if m != nil {
		return m.LastTick
	}
	return 0
}

func (m *NodeHostInfo) GetPlogInfoIncluded() bool {
	if m != nil {
		return m.PlogInfoIncluded
	}
	return false
}

func (m *NodeHostInfo) GetPlogInfo() []LogInfo {
	if m != nil {
		return m.PlogInfo
	}
	return nil
}

func (m *NodeHostInfo) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *NodeHostInfo) GetRPCAddress() string {
	if m != nil {
		return m.RPCAddress
	}
	return ""
}

// NodeHostCollection contains a list of NodeHostInfo messages.
type NodeHostCollection struct {
	Collection []NodeHostInfo `protobuf:"bytes,1,rep,name=collection" json:"collection"`
	Tick       uint64         `protobuf:"varint,2,opt,name=tick" json:"tick"`
}

func (m *NodeHostCollection) Reset()                    { *m = NodeHostCollection{} }
func (m *NodeHostCollection) String() string            { return proto.CompactTextString(m) }
func (*NodeHostCollection) ProtoMessage()               {}
func (*NodeHostCollection) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{16} }

func (m *NodeHostCollection) GetCollection() []NodeHostInfo {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *NodeHostCollection) GetTick() uint64 {
	if m != nil {
		return m.Tick
	}
	return 0
}

// ConfigChangeIndexList is the message used to report ConfChangeIndex values
// of clusters.
type ConfigChangeIndexList struct {
	Indexes map[uint64]uint64 `protobuf:"bytes,1,rep,name=indexes" json:"indexes,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *ConfigChangeIndexList) Reset()                    { *m = ConfigChangeIndexList{} }
func (m *ConfigChangeIndexList) String() string            { return proto.CompactTextString(m) }
func (*ConfigChangeIndexList) ProtoMessage()               {}
func (*ConfigChangeIndexList) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{17} }

func (m *ConfigChangeIndexList) GetIndexes() map[uint64]uint64 {
	if m != nil {
		return m.Indexes
	}
	return nil
}

// DeploymentInfo is a message that contains the deployment id generated by
// Drummer.
type DeploymentInfo struct {
	DeploymentId uint64 `protobuf:"varint,1,req,name=deployment_id,json=deploymentId" json:"deployment_id"`
}

func (m *DeploymentInfo) Reset()                    { *m = DeploymentInfo{} }
func (m *DeploymentInfo) String() string            { return proto.CompactTextString(m) }
func (*DeploymentInfo) ProtoMessage()               {}
func (*DeploymentInfo) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{18} }

func (m *DeploymentInfo) GetDeploymentId() uint64 {
	if m != nil {
		return m.DeploymentId
	}
	return 0
}

// Empty is a dummy message.
type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{19} }

// NodeHostRequest is the request message sent to NodeHost by Drummer.
type NodeHostRequest struct {
	Change            Request  `protobuf:"bytes,1,opt,name=change" json:"change"`
	NodeIdList        []uint64 `protobuf:"varint,2,rep,name=node_id_list,json=nodeIdList" json:"node_id_list,omitempty"`
	AddressList       []string `protobuf:"bytes,3,rep,name=address_list,json=addressList" json:"address_list,omitempty"`
	InstantiateNodeId uint64   `protobuf:"varint,4,opt,name=instantiate_node_id,json=instantiateNodeId" json:"instantiate_node_id"`
	RaftAddress       string   `protobuf:"bytes,5,opt,name=raft_address,json=raftAddress" json:"raft_address"`
	Join              bool     `protobuf:"varint,6,opt,name=join" json:"join"`
	Restore           bool     `protobuf:"varint,7,opt,name=restore" json:"restore"`
	AppName           string   `protobuf:"bytes,8,opt,name=app_name,json=appName" json:"app_name"`
	Config            Config   `protobuf:"bytes,9,opt,name=config" json:"config"`
}

func (m *NodeHostRequest) Reset()                    { *m = NodeHostRequest{} }
func (m *NodeHostRequest) String() string            { return proto.CompactTextString(m) }
func (*NodeHostRequest) ProtoMessage()               {}
func (*NodeHostRequest) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{20} }

func (m *NodeHostRequest) GetChange() Request {
	if m != nil {
		return m.Change
	}
	return Request{}
}

func (m *NodeHostRequest) GetNodeIdList() []uint64 {
	if m != nil {
		return m.NodeIdList
	}
	return nil
}

func (m *NodeHostRequest) GetAddressList() []string {
	if m != nil {
		return m.AddressList
	}
	return nil
}

func (m *NodeHostRequest) GetInstantiateNodeId() uint64 {
	if m != nil {
		return m.InstantiateNodeId
	}
	return 0
}

func (m *NodeHostRequest) GetRaftAddress() string {
	if m != nil {
		return m.RaftAddress
	}
	return ""
}

func (m *NodeHostRequest) GetJoin() bool {
	if m != nil {
		return m.Join
	}
	return false
}

func (m *NodeHostRequest) GetRestore() bool {
	if m != nil {
		return m.Restore
	}
	return false
}

func (m *NodeHostRequest) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *NodeHostRequest) GetConfig() Config {
	if m != nil {
		return m.Config
	}
	return Config{}
}

// NodeHostRequestCollection contains a list of NodeHostRequest messages.
type NodeHostRequestCollection struct {
	Requests []NodeHostRequest `protobuf:"bytes,1,rep,name=requests" json:"requests"`
}

func (m *NodeHostRequestCollection) Reset()         { *m = NodeHostRequestCollection{} }
func (m *NodeHostRequestCollection) String() string { return proto.CompactTextString(m) }
func (*NodeHostRequestCollection) ProtoMessage()    {}
func (*NodeHostRequestCollection) Descriptor() ([]byte, []int) {
	return fileDescriptorDrummer, []int{21}
}

func (m *NodeHostRequestCollection) GetRequests() []NodeHostRequest {
	if m != nil {
		return m.Requests
	}
	return nil
}

type DrummerConfigRequest struct {
	NodeId  uint64 `protobuf:"varint,1,req,name=node_id,json=nodeId" json:"node_id"`
	Address string `protobuf:"bytes,2,opt,name=address" json:"address"`
}

func (m *DrummerConfigRequest) Reset()                    { *m = DrummerConfigRequest{} }
func (m *DrummerConfigRequest) String() string            { return proto.CompactTextString(m) }
func (*DrummerConfigRequest) ProtoMessage()               {}
func (*DrummerConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{22} }

func (m *DrummerConfigRequest) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *DrummerConfigRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// Config is the message used to describe configurations for raft clusters.
type Config struct {
	ElectionRTT              uint64 `protobuf:"varint,1,opt,name=ElectionRTT" json:"ElectionRTT"`
	HeartbeatRTT             uint64 `protobuf:"varint,2,opt,name=HeartbeatRTT" json:"HeartbeatRTT"`
	CheckQuorum              bool   `protobuf:"varint,5,opt,name=CheckQuorum" json:"CheckQuorum"`
	CompactionOverhead       uint64 `protobuf:"varint,6,opt,name=CompactionOverhead" json:"CompactionOverhead"`
	SnapshotEntries          uint64 `protobuf:"varint,7,opt,name=SnapshotEntries" json:"SnapshotEntries"`
	RaftClusterAddresses     string `protobuf:"bytes,8,opt,name=RaftClusterAddresses" json:"RaftClusterAddresses"`
	DrummerAddress           string `protobuf:"bytes,9,opt,name=DrummerAddress" json:"DrummerAddress"`
	DrummerNodeID            uint64 `protobuf:"varint,10,opt,name=DrummerNodeID" json:"DrummerNodeID"`
	DrummerNodeHostDirectory string `protobuf:"bytes,11,opt,name=DrummerNodeHostDirectory" json:"DrummerNodeHostDirectory"`
	DrummerWALDirectory      string `protobuf:"bytes,12,opt,name=DrummerWALDirectory" json:"DrummerWALDirectory"`
	MutualTLS                bool   `protobuf:"varint,13,opt,name=MutualTLS" json:"MutualTLS"`
	CAFile                   string `protobuf:"bytes,14,opt,name=CAFile" json:"CAFile"`
	CertFile                 string `protobuf:"bytes,15,opt,name=CertFile" json:"CertFile"`
	KeyFile                  string `protobuf:"bytes,16,opt,name=KeyFile" json:"KeyFile"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptorDrummer, []int{23} }

func (m *Config) GetElectionRTT() uint64 {
	if m != nil {
		return m.ElectionRTT
	}
	return 0
}

func (m *Config) GetHeartbeatRTT() uint64 {
	if m != nil {
		return m.HeartbeatRTT
	}
	return 0
}

func (m *Config) GetCheckQuorum() bool {
	if m != nil {
		return m.CheckQuorum
	}
	return false
}

func (m *Config) GetCompactionOverhead() uint64 {
	if m != nil {
		return m.CompactionOverhead
	}
	return 0
}

func (m *Config) GetSnapshotEntries() uint64 {
	if m != nil {
		return m.SnapshotEntries
	}
	return 0
}

func (m *Config) GetRaftClusterAddresses() string {
	if m != nil {
		return m.RaftClusterAddresses
	}
	return ""
}

func (m *Config) GetDrummerAddress() string {
	if m != nil {
		return m.DrummerAddress
	}
	return ""
}

func (m *Config) GetDrummerNodeID() uint64 {
	if m != nil {
		return m.DrummerNodeID
	}
	return 0
}

func (m *Config) GetDrummerNodeHostDirectory() string {
	if m != nil {
		return m.DrummerNodeHostDirectory
	}
	return ""
}

func (m *Config) GetDrummerWALDirectory() string {
	if m != nil {
		return m.DrummerWALDirectory
	}
	return ""
}

func (m *Config) GetMutualTLS() bool {
	if m != nil {
		return m.MutualTLS
	}
	return false
}

func (m *Config) GetCAFile() string {
	if m != nil {
		return m.CAFile
	}
	return ""
}

func (m *Config) GetCertFile() string {
	if m != nil {
		return m.CertFile
	}
	return ""
}

func (m *Config) GetKeyFile() string {
	if m != nil {
		return m.KeyFile
	}
	return ""
}

func init() {
	proto.RegisterType((*Regions)(nil), "drummerpb.Regions")
	proto.RegisterType((*Cluster)(nil), "drummerpb.Cluster")
	proto.RegisterType((*ClusterCollection)(nil), "drummerpb.ClusterCollection")
	proto.RegisterType((*KV)(nil), "drummerpb.KV")
	proto.RegisterType((*Change)(nil), "drummerpb.Change")
	proto.RegisterType((*ChangeResponse)(nil), "drummerpb.ChangeResponse")
	proto.RegisterType((*Update)(nil), "drummerpb.Update")
	proto.RegisterType((*LookupRequest)(nil), "drummerpb.LookupRequest")
	proto.RegisterType((*LookupResponse)(nil), "drummerpb.LookupResponse")
	proto.RegisterType((*Request)(nil), "drummerpb.Request")
	proto.RegisterType((*ClusterStateRequest)(nil), "drummerpb.ClusterStateRequest")
	proto.RegisterType((*ClusterState)(nil), "drummerpb.ClusterState")
	proto.RegisterType((*ClusterInfo)(nil), "drummerpb.ClusterInfo")
	proto.RegisterType((*LogInfo)(nil), "drummerpb.LogInfo")
	proto.RegisterType((*ClusterStates)(nil), "drummerpb.ClusterStates")
	proto.RegisterType((*NodeHostInfo)(nil), "drummerpb.NodeHostInfo")
	proto.RegisterType((*NodeHostCollection)(nil), "drummerpb.NodeHostCollection")
	proto.RegisterType((*ConfigChangeIndexList)(nil), "drummerpb.ConfigChangeIndexList")
	proto.RegisterType((*DeploymentInfo)(nil), "drummerpb.DeploymentInfo")
	proto.RegisterType((*Empty)(nil), "drummerpb.Empty")
	proto.RegisterType((*NodeHostRequest)(nil), "drummerpb.NodeHostRequest")
	proto.RegisterType((*NodeHostRequestCollection)(nil), "drummerpb.NodeHostRequestCollection")
	proto.RegisterType((*DrummerConfigRequest)(nil), "drummerpb.DrummerConfigRequest")
	proto.RegisterType((*Config)(nil), "drummerpb.Config")
	proto.RegisterEnum("drummerpb.Change_Type", Change_Type_name, Change_Type_value)
	proto.RegisterEnum("drummerpb.ChangeResponse_Code", ChangeResponse_Code_name, ChangeResponse_Code_value)
	proto.RegisterEnum("drummerpb.Update_Type", Update_Type_name, Update_Type_value)
	proto.RegisterEnum("drummerpb.LookupRequest_Type", LookupRequest_Type_name, LookupRequest_Type_value)
	proto.RegisterEnum("drummerpb.LookupResponse_Code", LookupResponse_Code_name, LookupResponse_Code_value)
	proto.RegisterEnum("drummerpb.Request_Type", Request_Type_name, Request_Type_value)
	proto.RegisterEnum("drummerpb.ClusterState_State", ClusterState_State_name, ClusterState_State_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Drummer service

type DrummerClient interface {
	// AddDrummerServer adds a new server to the Drummer cluster.
	AddDrummerServer(ctx context.Context, in *DrummerConfigRequest, opts ...grpc.CallOption) (*Empty, error)
	// RemoveDrummerServer removes an existing server from the Drummer cluster.
	RemoveDrummerServer(ctx context.Context, in *DrummerConfigRequest, opts ...grpc.CallOption) (*Empty, error)
	// GetDeploymentInfo returns the DeploymentID value from Drummer.
	GetDeploymentInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DeploymentInfo, error)
	// GetClusterConfigChangeIndexList returns the ConfChangeIndex values of all
	// known clusters.
	GetClusterConfigChangeIndexList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ConfigChangeIndexList, error)
	// ReportAvailableNodeHost is used by nodehost to report its state details to
	// Drummer.
	ReportAvailableNodeHost(ctx context.Context, in *NodeHostInfo, opts ...grpc.CallOption) (*NodeHostRequestCollection, error)
	// GetNodeHostCollection returns a list of all known nodehosts from Drummer.
	GetNodeHostCollection(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeHostCollection, error)
	// GetClusters returns a list of all known clusters from Drummer.
	GetClusters(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ClusterCollection, error)
	// SubmitChange is used by Drummer clients to submit DrummerDB updates.
	SubmitChange(ctx context.Context, in *Change, opts ...grpc.CallOption) (*ChangeResponse, error)
	// SetBootstrapped sets the Drummer as bootstrapped. No more clusters can be defined
	// once Drummer is set as bootstrapped. Bootstrapped Drummer will start to schedule
	// raft nodes.
	SetBootstrapped(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ChangeResponse, error)
	// SetRegions sets region info for defined clusters.
	SetRegions(ctx context.Context, in *Regions, opts ...grpc.CallOption) (*ChangeResponse, error)
	// GetClusterStates returns ClusterStates for selected raft clusters.
	GetClusterStates(ctx context.Context, in *ClusterStateRequest, opts ...grpc.CallOption) (*ClusterStates, error)
}

type drummerClient struct {
	cc *grpc.ClientConn
}

func NewDrummerClient(cc *grpc.ClientConn) DrummerClient {
	return &drummerClient{cc}
}

func (c *drummerClient) AddDrummerServer(ctx context.Context, in *DrummerConfigRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/drummerpb.Drummer/AddDrummerServer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drummerClient) RemoveDrummerServer(ctx context.Context, in *DrummerConfigRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/drummerpb.Drummer/RemoveDrummerServer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drummerClient) GetDeploymentInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DeploymentInfo, error) {
	out := new(DeploymentInfo)
	err := grpc.Invoke(ctx, "/drummerpb.Drummer/GetDeploymentInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drummerClient) GetClusterConfigChangeIndexList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ConfigChangeIndexList, error) {
	out := new(ConfigChangeIndexList)
	err := grpc.Invoke(ctx, "/drummerpb.Drummer/GetClusterConfigChangeIndexList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drummerClient) ReportAvailableNodeHost(ctx context.Context, in *NodeHostInfo, opts ...grpc.CallOption) (*NodeHostRequestCollection, error) {
	out := new(NodeHostRequestCollection)
	err := grpc.Invoke(ctx, "/drummerpb.Drummer/ReportAvailableNodeHost", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drummerClient) GetNodeHostCollection(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeHostCollection, error) {
	out := new(NodeHostCollection)
	err := grpc.Invoke(ctx, "/drummerpb.Drummer/GetNodeHostCollection", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drummerClient) GetClusters(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ClusterCollection, error) {
	out := new(ClusterCollection)
	err := grpc.Invoke(ctx, "/drummerpb.Drummer/GetClusters", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drummerClient) SubmitChange(ctx context.Context, in *Change, opts ...grpc.CallOption) (*ChangeResponse, error) {
	out := new(ChangeResponse)
	err := grpc.Invoke(ctx, "/drummerpb.Drummer/SubmitChange", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drummerClient) SetBootstrapped(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ChangeResponse, error) {
	out := new(ChangeResponse)
	err := grpc.Invoke(ctx, "/drummerpb.Drummer/SetBootstrapped", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drummerClient) SetRegions(ctx context.Context, in *Regions, opts ...grpc.CallOption) (*ChangeResponse, error) {
	out := new(ChangeResponse)
	err := grpc.Invoke(ctx, "/drummerpb.Drummer/SetRegions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drummerClient) GetClusterStates(ctx context.Context, in *ClusterStateRequest, opts ...grpc.CallOption) (*ClusterStates, error) {
	out := new(ClusterStates)
	err := grpc.Invoke(ctx, "/drummerpb.Drummer/GetClusterStates", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Drummer service

type DrummerServer interface {
	// AddDrummerServer adds a new server to the Drummer cluster.
	AddDrummerServer(context.Context, *DrummerConfigRequest) (*Empty, error)
	// RemoveDrummerServer removes an existing server from the Drummer cluster.
	RemoveDrummerServer(context.Context, *DrummerConfigRequest) (*Empty, error)
	// GetDeploymentInfo returns the DeploymentID value from Drummer.
	GetDeploymentInfo(context.Context, *Empty) (*DeploymentInfo, error)
	// GetClusterConfigChangeIndexList returns the ConfChangeIndex values of all
	// known clusters.
	GetClusterConfigChangeIndexList(context.Context, *Empty) (*ConfigChangeIndexList, error)
	// ReportAvailableNodeHost is used by nodehost to report its state details to
	// Drummer.
	ReportAvailableNodeHost(context.Context, *NodeHostInfo) (*NodeHostRequestCollection, error)
	// GetNodeHostCollection returns a list of all known nodehosts from Drummer.
	GetNodeHostCollection(context.Context, *Empty) (*NodeHostCollection, error)
	// GetClusters returns a list of all known clusters from Drummer.
	GetClusters(context.Context, *Empty) (*ClusterCollection, error)
	// SubmitChange is used by Drummer clients to submit DrummerDB updates.
	SubmitChange(context.Context, *Change) (*ChangeResponse, error)
	// SetBootstrapped sets the Drummer as bootstrapped. No more clusters can be defined
	// once Drummer is set as bootstrapped. Bootstrapped Drummer will start to schedule
	// raft nodes.
	SetBootstrapped(context.Context, *Empty) (*ChangeResponse, error)
	// SetRegions sets region info for defined clusters.
	SetRegions(context.Context, *Regions) (*ChangeResponse, error)
	// GetClusterStates returns ClusterStates for selected raft clusters.
	GetClusterStates(context.Context, *ClusterStateRequest) (*ClusterStates, error)
}

func RegisterDrummerServer(s *grpc.Server, srv DrummerServer) {
	s.RegisterService(&_Drummer_serviceDesc, srv)
}

func _Drummer_AddDrummerServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DrummerConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrummerServer).AddDrummerServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/drummerpb.Drummer/AddDrummerServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrummerServer).AddDrummerServer(ctx, req.(*DrummerConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Drummer_RemoveDrummerServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DrummerConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrummerServer).RemoveDrummerServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/drummerpb.Drummer/RemoveDrummerServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrummerServer).RemoveDrummerServer(ctx, req.(*DrummerConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Drummer_GetDeploymentInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrummerServer).GetDeploymentInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/drummerpb.Drummer/GetDeploymentInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrummerServer).GetDeploymentInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Drummer_GetClusterConfigChangeIndexList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrummerServer).GetClusterConfigChangeIndexList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/drummerpb.Drummer/GetClusterConfigChangeIndexList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrummerServer).GetClusterConfigChangeIndexList(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Drummer_ReportAvailableNodeHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeHostInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrummerServer).ReportAvailableNodeHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/drummerpb.Drummer/ReportAvailableNodeHost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrummerServer).ReportAvailableNodeHost(ctx, req.(*NodeHostInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Drummer_GetNodeHostCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrummerServer).GetNodeHostCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/drummerpb.Drummer/GetNodeHostCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrummerServer).GetNodeHostCollection(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Drummer_GetClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrummerServer).GetClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/drummerpb.Drummer/GetClusters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrummerServer).GetClusters(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Drummer_SubmitChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Change)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrummerServer).SubmitChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/drummerpb.Drummer/SubmitChange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrummerServer).SubmitChange(ctx, req.(*Change))
	}
	return interceptor(ctx, in, info, handler)
}

func _Drummer_SetBootstrapped_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrummerServer).SetBootstrapped(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/drummerpb.Drummer/SetBootstrapped",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrummerServer).SetBootstrapped(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Drummer_SetRegions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Regions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrummerServer).SetRegions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/drummerpb.Drummer/SetRegions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrummerServer).SetRegions(ctx, req.(*Regions))
	}
	return interceptor(ctx, in, info, handler)
}

func _Drummer_GetClusterStates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrummerServer).GetClusterStates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/drummerpb.Drummer/GetClusterStates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrummerServer).GetClusterStates(ctx, req.(*ClusterStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Drummer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "drummerpb.Drummer",
	HandlerType: (*DrummerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddDrummerServer",
			Handler:    _Drummer_AddDrummerServer_Handler,
		},
		{
			MethodName: "RemoveDrummerServer",
			Handler:    _Drummer_RemoveDrummerServer_Handler,
		},
		{
			MethodName: "GetDeploymentInfo",
			Handler:    _Drummer_GetDeploymentInfo_Handler,
		},
		{
			MethodName: "GetClusterConfigChangeIndexList",
			Handler:    _Drummer_GetClusterConfigChangeIndexList_Handler,
		},
		{
			MethodName: "ReportAvailableNodeHost",
			Handler:    _Drummer_ReportAvailableNodeHost_Handler,
		},
		{
			MethodName: "GetNodeHostCollection",
			Handler:    _Drummer_GetNodeHostCollection_Handler,
		},
		{
			MethodName: "GetClusters",
			Handler:    _Drummer_GetClusters_Handler,
		},
		{
			MethodName: "SubmitChange",
			Handler:    _Drummer_SubmitChange_Handler,
		},
		{
			MethodName: "SetBootstrapped",
			Handler:    _Drummer_SetBootstrapped_Handler,
		},
		{
			MethodName: "SetRegions",
			Handler:    _Drummer_SetRegions_Handler,
		},
		{
			MethodName: "GetClusterStates",
			Handler:    _Drummer_GetClusterStates_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "drummer.proto",
}

func (m *Regions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Regions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Region) > 0 {
		for _, s := range m.Region {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Count) > 0 {
		for _, num := range m.Count {
			dAtA[i] = 0x10
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, num := range m.Members {
			dAtA[i] = 0x8
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.ClusterId))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.AppName)))
	i += copy(dAtA[i:], m.AppName)
	return i, nil
}

func (m *ClusterCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Clusters) > 0 {
		for _, msg := range m.Clusters {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *KV) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KV) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.Key)))
	i += copy(dAtA[i:], m.Key)
	dAtA[i] = 0x12
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	dAtA[i] = 0x18
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.InstanceId))
	dAtA[i] = 0x20
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.Tick))
	dAtA[i] = 0x28
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.OldInstanceId))
	dAtA[i] = 0x30
	i++
	if m.Finalized {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *Change) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Change) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x10
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.ClusterId))
	if len(m.Members) > 0 {
		for _, num := range m.Members {
			dAtA[i] = 0x18
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.AppName)))
	i += copy(dAtA[i:], m.AppName)
	return i, nil
}

func (m *ChangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.Code))
	return i, nil
}

func (m *Update) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Update) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.Change.Size()))
	n1, err := m.Change.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x10
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.KvUpdate.Size()))
	n2, err := m.KvUpdate.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x22
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.NodehostInfo.Size()))
	n3, err := m.NodehostInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x2a
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.Requests.Size()))
	n4, err := m.Requests.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *LookupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LookupRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.Type))
	if len(m.ClusterIdList) > 0 {
		for _, num := range m.ClusterIdList {
			dAtA[i] = 0x10
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.KvLookup.Size()))
	n5, err := m.KvLookup.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x20
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.RequestsId))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.Address)))
	i += copy(dAtA[i:], m.Address)
	dAtA[i] = 0x32
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.Stats.Size()))
	n6, err := m.Stats.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *LookupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LookupResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.Code))
	if len(m.Clusters) > 0 {
		for _, msg := range m.Clusters {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.KvResult.Size()))
	n7, err := m.KvResult.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x22
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.Requests.Size()))
	n8, err := m.Requests.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x10
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.ClusterId))
	if len(m.Members) > 0 {
		for _, num := range m.Members {
			dAtA[i] = 0x18
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.AppName)))
	i += copy(dAtA[i:], m.AppName)
	dAtA[i] = 0x28
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.ConfChangeId))
	return i, nil
}

func (m *ClusterStateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterIdList) > 0 {
		for _, num := range m.ClusterIdList {
			dAtA[i] = 0x8
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *ClusterState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.ClusterId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.LeaderNodeId))
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			dAtA[i] = 0x1a
			i++
			v := m.Nodes[k]
			mapSize := 1 + sovDrummer(uint64(k)) + 1 + len(v) + sovDrummer(uint64(len(v)))
			i = encodeVarintDrummer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.RPCAddresses) > 0 {
		for k, _ := range m.RPCAddresses {
			dAtA[i] = 0x22
			i++
			v := m.RPCAddresses[k]
			mapSize := 1 + sovDrummer(uint64(k)) + 1 + len(v) + sovDrummer(uint64(len(v)))
			i = encodeVarintDrummer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.State))
	dAtA[i] = 0x30
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.ConfigChangeIndex))
	return i, nil
}

func (m *ClusterInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.ClusterId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.NodeId))
	dAtA[i] = 0x18
	i++
	if m.IsLeader {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			dAtA[i] = 0x22
			i++
			v := m.Nodes[k]
			mapSize := 1 + sovDrummer(uint64(k)) + 1 + len(v) + sovDrummer(uint64(len(v)))
			i = encodeVarintDrummer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.ConfigChangeIndex))
	dAtA[i] = 0x30
	i++
	if m.Incomplete {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x38
	i++
	if m.Pending {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *LogInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.ClusterId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.NodeId))
	return i, nil
}

func (m *ClusterStates) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStates) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Collection) > 0 {
		for _, msg := range m.Collection {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NodeHostInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeHostInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.RaftAddress)))
	i += copy(dAtA[i:], m.RaftAddress)
	if len(m.ClusterInfo) > 0 {
		for _, msg := range m.ClusterInfo {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClusterIdList) > 0 {
		for _, num := range m.ClusterIdList {
			dAtA[i] = 0x18
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.LastTick))
	dAtA[i] = 0x28
	i++
	if m.PlogInfoIncluded {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.PlogInfo) > 0 {
		for _, msg := range m.PlogInfo {
			dAtA[i] = 0x32
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.Region)))
	i += copy(dAtA[i:], m.Region)
	dAtA[i] = 0x42
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.RPCAddress)))
	i += copy(dAtA[i:], m.RPCAddress)
	return i, nil
}

func (m *NodeHostCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeHostCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Collection) > 0 {
		for _, msg := range m.Collection {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.Tick))
	return i, nil
}

func (m *ConfigChangeIndexList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigChangeIndexList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		for k, _ := range m.Indexes {
			dAtA[i] = 0xa
			i++
			v := m.Indexes[k]
			mapSize := 1 + sovDrummer(uint64(k)) + 1 + sovDrummer(uint64(v))
			i = encodeVarintDrummer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *DeploymentInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.DeploymentId))
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NodeHostRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeHostRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.Change.Size()))
	n9, err := m.Change.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.NodeIdList) > 0 {
		for _, num := range m.NodeIdList {
			dAtA[i] = 0x10
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(num))
		}
	}
	if len(m.AddressList) > 0 {
		for _, s := range m.AddressList {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.InstantiateNodeId))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.RaftAddress)))
	i += copy(dAtA[i:], m.RaftAddress)
	dAtA[i] = 0x30
	i++
	if m.Join {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x38
	i++
	if m.Restore {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x42
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.AppName)))
	i += copy(dAtA[i:], m.AppName)
	dAtA[i] = 0x4a
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.Config.Size()))
	n10, err := m.Config.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	return i, nil
}

func (m *NodeHostRequestCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeHostRequestCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, msg := range m.Requests {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDrummer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DrummerConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DrummerConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.NodeId))
	dAtA[i] = 0x12
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.Address)))
	i += copy(dAtA[i:], m.Address)
	return i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.ElectionRTT))
	dAtA[i] = 0x10
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.HeartbeatRTT))
	dAtA[i] = 0x28
	i++
	if m.CheckQuorum {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x30
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.CompactionOverhead))
	dAtA[i] = 0x38
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.SnapshotEntries))
	dAtA[i] = 0x42
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.RaftClusterAddresses)))
	i += copy(dAtA[i:], m.RaftClusterAddresses)
	dAtA[i] = 0x4a
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.DrummerAddress)))
	i += copy(dAtA[i:], m.DrummerAddress)
	dAtA[i] = 0x50
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(m.DrummerNodeID))
	dAtA[i] = 0x5a
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.DrummerNodeHostDirectory)))
	i += copy(dAtA[i:], m.DrummerNodeHostDirectory)
	dAtA[i] = 0x62
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.DrummerWALDirectory)))
	i += copy(dAtA[i:], m.DrummerWALDirectory)
	dAtA[i] = 0x68
	i++
	if m.MutualTLS {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x72
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.CAFile)))
	i += copy(dAtA[i:], m.CAFile)
	dAtA[i] = 0x7a
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.CertFile)))
	i += copy(dAtA[i:], m.CertFile)
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintDrummer(dAtA, i, uint64(len(m.KeyFile)))
	i += copy(dAtA[i:], m.KeyFile)
	return i, nil
}

func encodeVarintDrummer(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Regions) Size() (n int) {
	var l int
	_ = l
	if len(m.Region) > 0 {
		for _, s := range m.Region {
			l = len(s)
			n += 1 + l + sovDrummer(uint64(l))
		}
	}
	if len(m.Count) > 0 {
		for _, e := range m.Count {
			n += 1 + sovDrummer(uint64(e))
		}
	}
	return n
}

func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			n += 1 + sovDrummer(uint64(e))
		}
	}
	n += 1 + sovDrummer(uint64(m.ClusterId))
	l = len(m.AppName)
	n += 1 + l + sovDrummer(uint64(l))
	return n
}

func (m *ClusterCollection) Size() (n int) {
	var l int
	_ = l
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovDrummer(uint64(l))
		}
	}
	return n
}

func (m *KV) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	n += 1 + l + sovDrummer(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovDrummer(uint64(l))
	n += 1 + sovDrummer(uint64(m.InstanceId))
	n += 1 + sovDrummer(uint64(m.Tick))
	n += 1 + sovDrummer(uint64(m.OldInstanceId))
	n += 2
	return n
}

func (m *Change) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDrummer(uint64(m.Type))
	n += 1 + sovDrummer(uint64(m.ClusterId))
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			n += 1 + sovDrummer(uint64(e))
		}
	}
	l = len(m.AppName)
	n += 1 + l + sovDrummer(uint64(l))
	return n
}

func (m *ChangeResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDrummer(uint64(m.Code))
	return n
}

func (m *Update) Size() (n int) {
	var l int
	_ = l
	l = m.Change.Size()
	n += 1 + l + sovDrummer(uint64(l))
	n += 1 + sovDrummer(uint64(m.Type))
	l = m.KvUpdate.Size()
	n += 1 + l + sovDrummer(uint64(l))
	l = m.NodehostInfo.Size()
	n += 1 + l + sovDrummer(uint64(l))
	l = m.Requests.Size()
	n += 1 + l + sovDrummer(uint64(l))
	return n
}

func (m *LookupRequest) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDrummer(uint64(m.Type))
	if len(m.ClusterIdList) > 0 {
		for _, e := range m.ClusterIdList {
			n += 1 + sovDrummer(uint64(e))
		}
	}
	l = m.KvLookup.Size()
	n += 1 + l + sovDrummer(uint64(l))
	n += 1 + sovDrummer(uint64(m.RequestsId))
	l = len(m.Address)
	n += 1 + l + sovDrummer(uint64(l))
	l = m.Stats.Size()
	n += 1 + l + sovDrummer(uint64(l))
	return n
}

func (m *LookupResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDrummer(uint64(m.Code))
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovDrummer(uint64(l))
		}
	}
	l = m.KvResult.Size()
	n += 1 + l + sovDrummer(uint64(l))
	l = m.Requests.Size()
	n += 1 + l + sovDrummer(uint64(l))
	return n
}

func (m *Request) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDrummer(uint64(m.Type))
	n += 1 + sovDrummer(uint64(m.ClusterId))
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			n += 1 + sovDrummer(uint64(e))
		}
	}
	l = len(m.AppName)
	n += 1 + l + sovDrummer(uint64(l))
	n += 1 + sovDrummer(uint64(m.ConfChangeId))
	return n
}

func (m *ClusterStateRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.ClusterIdList) > 0 {
		for _, e := range m.ClusterIdList {
			n += 1 + sovDrummer(uint64(e))
		}
	}
	return n
}

func (m *ClusterState) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDrummer(uint64(m.ClusterId))
	n += 1 + sovDrummer(uint64(m.LeaderNodeId))
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovDrummer(uint64(k)) + 1 + len(v) + sovDrummer(uint64(len(v)))
			n += mapEntrySize + 1 + sovDrummer(uint64(mapEntrySize))
		}
	}
	if len(m.RPCAddresses) > 0 {
		for k, v := range m.RPCAddresses {
			_ = k
			_ = v
			mapEntrySize := 1 + sovDrummer(uint64(k)) + 1 + len(v) + sovDrummer(uint64(len(v)))
			n += mapEntrySize + 1 + sovDrummer(uint64(mapEntrySize))
		}
	}
	n += 1 + sovDrummer(uint64(m.State))
	n += 1 + sovDrummer(uint64(m.ConfigChangeIndex))
	return n
}

func (m *ClusterInfo) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDrummer(uint64(m.ClusterId))
	n += 1 + sovDrummer(uint64(m.NodeId))
	n += 2
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovDrummer(uint64(k)) + 1 + len(v) + sovDrummer(uint64(len(v)))
			n += mapEntrySize + 1 + sovDrummer(uint64(mapEntrySize))
		}
	}
	n += 1 + sovDrummer(uint64(m.ConfigChangeIndex))
	n += 2
	n += 2
	return n
}

func (m *LogInfo) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDrummer(uint64(m.ClusterId))
	n += 1 + sovDrummer(uint64(m.NodeId))
	return n
}

func (m *ClusterStates) Size() (n int) {
	var l int
	_ = l
	if len(m.Collection) > 0 {
		for _, e := range m.Collection {
			l = e.Size()
			n += 1 + l + sovDrummer(uint64(l))
		}
	}
	return n
}

func (m *NodeHostInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.RaftAddress)
	n += 1 + l + sovDrummer(uint64(l))
	if len(m.ClusterInfo) > 0 {
		for _, e := range m.ClusterInfo {
			l = e.Size()
			n += 1 + l + sovDrummer(uint64(l))
		}
	}
	if len(m.ClusterIdList) > 0 {
		for _, e := range m.ClusterIdList {
			n += 1 + sovDrummer(uint64(e))
		}
	}
	n += 1 + sovDrummer(uint64(m.LastTick))
	n += 2
	if len(m.PlogInfo) > 0 {
		for _, e := range m.PlogInfo {
			l = e.Size()
			n += 1 + l + sovDrummer(uint64(l))
		}
	}
	l = len(m.Region)
	n += 1 + l + sovDrummer(uint64(l))
	l = len(m.RPCAddress)
	n += 1 + l + sovDrummer(uint64(l))
	return n
}

func (m *NodeHostCollection) Size() (n int) {
	var l int
	_ = l
	if len(m.Collection) > 0 {
		for _, e := range m.Collection {
			l = e.Size()
			n += 1 + l + sovDrummer(uint64(l))
		}
	}
	n += 1 + sovDrummer(uint64(m.Tick))
	return n
}

func (m *ConfigChangeIndexList) Size() (n int) {
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		for k, v := range m.Indexes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovDrummer(uint64(k)) + 1 + sovDrummer(uint64(v))
			n += mapEntrySize + 1 + sovDrummer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DeploymentInfo) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDrummer(uint64(m.DeploymentId))
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NodeHostRequest) Size() (n int) {
	var l int
	_ = l
	l = m.Change.Size()
	n += 1 + l + sovDrummer(uint64(l))
	if len(m.NodeIdList) > 0 {
		for _, e := range m.NodeIdList {
			n += 1 + sovDrummer(uint64(e))
		}
	}
	if len(m.AddressList) > 0 {
		for _, s := range m.AddressList {
			l = len(s)
			n += 1 + l + sovDrummer(uint64(l))
		}
	}
	n += 1 + sovDrummer(uint64(m.InstantiateNodeId))
	l = len(m.RaftAddress)
	n += 1 + l + sovDrummer(uint64(l))
	n += 2
	n += 2
	l = len(m.AppName)
	n += 1 + l + sovDrummer(uint64(l))
	l = m.Config.Size()
	n += 1 + l + sovDrummer(uint64(l))
	return n
}

func (m *NodeHostRequestCollection) Size() (n int) {
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovDrummer(uint64(l))
		}
	}
	return n
}

func (m *DrummerConfigRequest) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDrummer(uint64(m.NodeId))
	l = len(m.Address)
	n += 1 + l + sovDrummer(uint64(l))
	return n
}

func (m *Config) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDrummer(uint64(m.ElectionRTT))
	n += 1 + sovDrummer(uint64(m.HeartbeatRTT))
	n += 2
	n += 1 + sovDrummer(uint64(m.CompactionOverhead))
	n += 1 + sovDrummer(uint64(m.SnapshotEntries))
	l = len(m.RaftClusterAddresses)
	n += 1 + l + sovDrummer(uint64(l))
	l = len(m.DrummerAddress)
	n += 1 + l + sovDrummer(uint64(l))
	n += 1 + sovDrummer(uint64(m.DrummerNodeID))
	l = len(m.DrummerNodeHostDirectory)
	n += 1 + l + sovDrummer(uint64(l))
	l = len(m.DrummerWALDirectory)
	n += 1 + l + sovDrummer(uint64(l))
	n += 2
	l = len(m.CAFile)
	n += 1 + l + sovDrummer(uint64(l))
	l = len(m.CertFile)
	n += 1 + l + sovDrummer(uint64(l))
	l = len(m.KeyFile)
	n += 2 + l + sovDrummer(uint64(l))
	return n
}

func sovDrummer(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDrummer(x uint64) (n int) {
	return sovDrummer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Regions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Regions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Regions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = append(m.Region, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Count = append(m.Count, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDrummer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Count = append(m.Count, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Members = append(m.Members, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDrummer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Members = append(m.Members, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &Cluster{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KV) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			m.InstanceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tick", wireType)
			}
			m.Tick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tick |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldInstanceId", wireType)
			}
			m.OldInstanceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldInstanceId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Finalized = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("key")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Change) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Change: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Change: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Change_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Members = append(m.Members, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDrummer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Members = append(m.Members, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("type")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("cluster_id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ChangeResponse_Code(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("code")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Update) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Update: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Update: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Change.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Update_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.KvUpdate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodehostInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NodehostInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Requests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (LookupRequest_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ClusterIdList = append(m.ClusterIdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDrummer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ClusterIdList = append(m.ClusterIdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIdList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvLookup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.KvLookup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestsId", wireType)
			}
			m.RequestsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestsId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (LookupResponse_Code(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &Cluster{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.KvResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Requests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Request_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Members = append(m.Members, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDrummer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Members = append(m.Members, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfChangeId", wireType)
			}
			m.ConfChangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfChangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("type")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("cluster_id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ClusterIdList = append(m.ClusterIdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDrummer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ClusterIdList = append(m.ClusterIdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIdList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterState) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderNodeId", wireType)
			}
			m.LeaderNodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderNodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nodes == nil {
				m.Nodes = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDrummer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDrummer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDrummer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RPCAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RPCAddresses == nil {
				m.RPCAddresses = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDrummer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDrummer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDrummer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RPCAddresses[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (ClusterState_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigChangeIndex", wireType)
			}
			m.ConfigChangeIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigChangeIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("cluster_id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeader = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nodes == nil {
				m.Nodes = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDrummer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDrummer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDrummer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigChangeIndex", wireType)
			}
			m.ConfigChangeIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigChangeIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incomplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Incomplete = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pending", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pending = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("cluster_id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("node_id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("cluster_id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("node_id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStates) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStates: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStates: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collection = append(m.Collection, &ClusterState{})
			if err := m.Collection[len(m.Collection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeHostInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeHostInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeHostInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterInfo = append(m.ClusterInfo, ClusterInfo{})
			if err := m.ClusterInfo[len(m.ClusterInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ClusterIdList = append(m.ClusterIdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDrummer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ClusterIdList = append(m.ClusterIdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIdList", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTick", wireType)
			}
			m.LastTick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastTick |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlogInfoIncluded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlogInfoIncluded = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlogInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlogInfo = append(m.PlogInfo, LogInfo{})
			if err := m.PlogInfo[len(m.PlogInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RPCAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RPCAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("raft_address")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeHostCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeHostCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeHostCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collection = append(m.Collection, NodeHostInfo{})
			if err := m.Collection[len(m.Collection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tick", wireType)
			}
			m.Tick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tick |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigChangeIndexList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChangeIndexList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChangeIndexList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Indexes == nil {
				m.Indexes = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDrummer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDrummer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Indexes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			m.DeploymentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeploymentId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("deployment_id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeHostRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeHostRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeHostRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Change.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NodeIdList = append(m.NodeIdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDrummer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrummer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NodeIdList = append(m.NodeIdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIdList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressList = append(m.AddressList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstantiateNodeId", wireType)
			}
			m.InstantiateNodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstantiateNodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Join = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Restore = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeHostRequestCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeHostRequestCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeHostRequestCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, NodeHostRequest{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DrummerConfigRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DrummerConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DrummerConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("node_id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectionRTT", wireType)
			}
			m.ElectionRTT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElectionRTT |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatRTT", wireType)
			}
			m.HeartbeatRTT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeartbeatRTT |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckQuorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckQuorum = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactionOverhead", wireType)
			}
			m.CompactionOverhead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactionOverhead |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotEntries", wireType)
			}
			m.SnapshotEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotEntries |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftClusterAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftClusterAddresses = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrummerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DrummerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrummerNodeID", wireType)
			}
			m.DrummerNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrummerNodeID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrummerNodeHostDirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DrummerNodeHostDirectory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrummerWALDirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DrummerWALDirectory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MutualTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MutualTLS = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CAFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CAFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrummer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrummer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrummer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDrummer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDrummer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDrummer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDrummer
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDrummer
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDrummer(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDrummer = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDrummer   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("drummer.proto", fileDescriptorDrummer) }

var fileDescriptorDrummer = []byte{
	// 2091 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x72, 0xdb, 0xc6,
	0x1d, 0x17, 0x48, 0x8a, 0x1f, 0x7f, 0x92, 0x12, 0xb4, 0xfe, 0x42, 0x34, 0xb1, 0x4c, 0xa3, 0x4e,
	0xaa, 0x78, 0x12, 0xd9, 0xd1, 0xb8, 0xb5, 0x9b, 0xd6, 0x4d, 0x28, 0x12, 0x92, 0x59, 0xd1, 0xa4,
	0x03, 0x42, 0x76, 0xd2, 0x0b, 0x07, 0x22, 0x56, 0x12, 0x2a, 0x10, 0x40, 0x81, 0xa5, 0xa6, 0xea,
	0xb1, 0x0f, 0xd0, 0xe9, 0xbd, 0x2f, 0xd0, 0x53, 0x6f, 0x7d, 0x87, 0xcc, 0xf4, 0xd0, 0x3e, 0x41,
	0xa7, 0xe3, 0x3e, 0x40, 0xa7, 0xed, 0xad, 0xb9, 0x74, 0xb0, 0xbb, 0x00, 0x17, 0x04, 0x68, 0x79,
	0x5a, 0xf7, 0xc2, 0x21, 0xfe, 0x5f, 0xbb, 0xfb, 0xff, 0xfd, 0xbf, 0x76, 0xa1, 0x69, 0x05, 0xb3,
	0xe9, 0x14, 0x07, 0x3b, 0x7e, 0xe0, 0x11, 0x0f, 0xd5, 0xf8, 0xa7, 0x7f, 0xbc, 0xf9, 0xc9, 0xa9,
	0x4d, 0xce, 0x66, 0xc7, 0x3b, 0x13, 0x6f, 0xfa, 0xe0, 0xd4, 0x3b, 0xf5, 0x1e, 0x50, 0x89, 0xe3,
	0xd9, 0x09, 0xfd, 0xa2, 0x1f, 0xf4, 0x1f, 0xd3, 0x54, 0x1f, 0x43, 0x45, 0xc7, 0xa7, 0xb6, 0xe7,
	0x86, 0xe8, 0x26, 0x94, 0x03, 0xfa, 0x57, 0x91, 0x5a, 0xc5, 0xed, 0x9a, 0xce, 0xbf, 0xd0, 0x75,
	0x58, 0x9d, 0x78, 0x33, 0x97, 0x28, 0x85, 0x56, 0x71, 0xbb, 0xa4, 0xb3, 0x0f, 0xd5, 0x86, 0x4a,
	0xc7, 0x99, 0x85, 0x04, 0x07, 0x48, 0x81, 0xca, 0x14, 0x4f, 0x8f, 0x71, 0x10, 0x52, 0xcd, 0x92,
	0x1e, 0x7f, 0xa2, 0xef, 0x00, 0x4c, 0x98, 0xd0, 0xd8, 0xb6, 0x94, 0x42, 0x4b, 0xda, 0x2e, 0xed,
	0x95, 0xbe, 0xf9, 0xcb, 0x9d, 0x15, 0xbd, 0xc6, 0xe9, 0x3d, 0x0b, 0xdd, 0x81, 0xaa, 0xe9, 0xfb,
	0x63, 0xd7, 0x9c, 0x62, 0xa5, 0xd8, 0x92, 0xb6, 0x6b, 0x5c, 0xa4, 0x62, 0xfa, 0xfe, 0xc0, 0x9c,
	0x62, 0xb5, 0x03, 0x1b, 0x7c, 0xa9, 0x8e, 0xe7, 0x38, 0x78, 0x42, 0xa2, 0x5d, 0xed, 0x40, 0x95,
	0x9b, 0x60, 0xab, 0xd6, 0x77, 0xd1, 0x4e, 0xe2, 0x85, 0x1d, 0x2e, 0xaf, 0x27, 0x32, 0xea, 0x1f,
	0x25, 0x28, 0x1c, 0xbe, 0x44, 0x37, 0xa1, 0x78, 0x8e, 0x2f, 0x15, 0xa9, 0x55, 0x48, 0xd6, 0x89,
	0x08, 0x68, 0x13, 0x56, 0x2f, 0x4c, 0x67, 0x86, 0x95, 0x82, 0xc0, 0x61, 0x24, 0xf4, 0x01, 0xd4,
	0x6d, 0x37, 0x24, 0xa6, 0x3b, 0xc1, 0xd1, 0x31, 0x8a, 0xc2, 0x31, 0x20, 0x66, 0xf4, 0x2c, 0xa4,
	0x40, 0x89, 0xd8, 0x93, 0x73, 0xa5, 0x24, 0xf0, 0x29, 0x05, 0x7d, 0x0c, 0xeb, 0x9e, 0x63, 0x8d,
	0x45, 0x23, 0xab, 0x82, 0x50, 0xd3, 0x73, 0xac, 0xde, 0xdc, 0x8e, 0x0a, 0xb5, 0x13, 0xdb, 0x35,
	0x1d, 0xfb, 0x97, 0xd8, 0x52, 0xca, 0x2d, 0x69, 0xbb, 0x1a, 0xfb, 0x2c, 0x21, 0xab, 0xbf, 0x97,
	0xa0, 0xdc, 0x39, 0x33, 0xdd, 0x53, 0x8c, 0x1e, 0x42, 0x89, 0x5c, 0xfa, 0x98, 0x1e, 0x69, 0x6d,
	0xf7, 0xa6, 0xe8, 0x04, 0x2a, 0xb0, 0x63, 0x5c, 0xfa, 0x38, 0xd9, 0xce, 0xa5, 0x8f, 0x33, 0xa8,
	0x14, 0xf2, 0x50, 0x11, 0x40, 0x2d, 0xa6, 0x41, 0x15, 0xf1, 0x2a, 0xe5, 0xe1, 0x85, 0xa0, 0x14,
	0xad, 0x89, 0x00, 0xca, 0x1d, 0x5d, 0x6b, 0x1b, 0x9a, 0xbc, 0xa2, 0xfe, 0x49, 0x82, 0x35, 0xb6,
	0x1f, 0x1d, 0x87, 0xbe, 0xe7, 0x86, 0x18, 0x3d, 0x81, 0xd2, 0xc4, 0xb3, 0xe2, 0x8d, 0x6f, 0x65,
	0x36, 0x1e, 0x0b, 0xee, 0x74, 0x3c, 0x2b, 0x39, 0x40, 0xa4, 0xa1, 0xfe, 0x4a, 0x82, 0x52, 0x44,
	0x44, 0x65, 0x28, 0x0c, 0x0f, 0xe5, 0x15, 0x74, 0x03, 0x36, 0x3a, 0xfd, 0xa3, 0x91, 0xa1, 0xe9,
	0xe3, 0xc1, 0xd0, 0x18, 0xef, 0x0f, 0x8f, 0x06, 0x5d, 0x59, 0x42, 0x08, 0xd6, 0x3a, 0xc3, 0xc1,
	0x7e, 0xbf, 0xd7, 0x89, 0x69, 0x05, 0xb4, 0x01, 0xcd, 0xa3, 0xc1, 0xe1, 0x60, 0xf8, 0x6a, 0x30,
	0xd6, 0x35, 0x43, 0xff, 0x5a, 0x2e, 0x46, 0xa4, 0x58, 0x5b, 0xfb, 0xaa, 0x37, 0x32, 0xe4, 0x12,
	0x92, 0xa1, 0xb1, 0x37, 0x1c, 0x1a, 0x23, 0x43, 0x6f, 0xbf, 0x78, 0xa1, 0x75, 0xe5, 0x55, 0xb4,
	0x0e, 0x75, 0x5d, 0x3b, 0xe8, 0x0d, 0x07, 0xa3, 0xf1, 0x48, 0x33, 0xe4, 0xb2, 0xfa, 0x8f, 0x02,
	0x94, 0x8f, 0x7c, 0xcb, 0x24, 0x18, 0x3d, 0x80, 0xf2, 0x84, 0x6e, 0x59, 0x91, 0x5a, 0xd2, 0x76,
	0x7d, 0x77, 0x23, 0x73, 0x16, 0xbe, 0x7d, 0x2e, 0x96, 0x60, 0x56, 0xc8, 0x60, 0xc6, 0x2c, 0x66,
	0x31, 0x7b, 0x08, 0xb5, 0xf3, 0x8b, 0xf1, 0x8c, 0x72, 0x69, 0x04, 0xd6, 0x77, 0x9b, 0x82, 0xda,
	0xe1, 0x4b, 0x2e, 0x5d, 0x3d, 0xbf, 0xe0, 0x9b, 0xda, 0x83, 0xa6, 0xeb, 0x59, 0xf8, 0xcc, 0x0b,
	0xc9, 0xd8, 0x76, 0x4f, 0x3c, 0x8a, 0x55, 0x7d, 0xf7, 0x96, 0xa0, 0x35, 0xf0, 0x2c, 0xfc, 0xcc,
	0x0b, 0x49, 0xcf, 0x3d, 0xf1, 0xb8, 0x7e, 0x23, 0xd6, 0x89, 0x68, 0x68, 0x1f, 0xaa, 0x01, 0xfe,
	0xf9, 0x0c, 0x87, 0x24, 0xa4, 0x11, 0x5b, 0xdf, 0xbd, 0x97, 0xa3, 0xae, 0x33, 0x91, 0x79, 0x72,
	0xc6, 0x7b, 0x89, 0x75, 0xd5, 0x7d, 0x1e, 0x11, 0x75, 0xa8, 0x70, 0x4f, 0xcb, 0x2b, 0x11, 0x78,
	0x87, 0x2f, 0x65, 0x09, 0x55, 0xa1, 0x64, 0xf4, 0x3a, 0x87, 0x0c, 0x9b, 0xc1, 0xb0, 0xab, 0x3d,
	0x1b, 0x8e, 0x8c, 0x71, 0x6f, 0xb0, 0x3f, 0x94, 0x8b, 0xa8, 0x01, 0x55, 0x5d, 0xfb, 0xf2, 0x48,
	0x1b, 0x19, 0x23, 0xb9, 0xa4, 0x7e, 0x5b, 0x80, 0x66, 0xdf, 0xf3, 0xce, 0x67, 0x3e, 0x5f, 0x13,
	0x3d, 0x4e, 0x45, 0xff, 0x6d, 0x61, 0x77, 0x29, 0xb9, 0xac, 0x43, 0x3f, 0x84, 0xf5, 0x79, 0x12,
	0x8c, 0x1d, 0x3b, 0x8c, 0xeb, 0x5b, 0x33, 0xc9, 0x81, 0xbe, 0x1d, 0x12, 0xee, 0x78, 0x87, 0x1a,
	0xbb, 0xc2, 0xf1, 0x6c, 0xc5, 0xa8, 0x5c, 0xc4, 0x07, 0x8f, 0xf2, 0x4b, 0x2c, 0x07, 0x10, 0x33,
	0x7a, 0x16, 0xda, 0x82, 0x8a, 0x69, 0x59, 0x01, 0x0e, 0x99, 0x6b, 0xe7, 0x59, 0xc4, 0x88, 0xe8,
	0x33, 0x58, 0x0d, 0x89, 0x49, 0x42, 0x5a, 0x02, 0xea, 0xe9, 0xfc, 0x60, 0x3b, 0x1c, 0x11, 0x93,
	0x60, 0x7e, 0xc0, 0xb8, 0x62, 0x51, 0x15, 0xd5, 0x78, 0x93, 0xbf, 0x6f, 0xc0, 0xc6, 0xa8, 0xf3,
	0x4c, 0xeb, 0x1e, 0xf5, 0x35, 0x7d, 0xdc, 0x19, 0x0e, 0x0c, 0xed, 0x2b, 0x63, 0xd1, 0xd3, 0x34,
	0x75, 0x78, 0x4e, 0x8c, 0x8c, 0xb6, 0xa1, 0x8d, 0xe4, 0x55, 0xf5, 0xb7, 0x05, 0x58, 0x8b, 0xbd,
	0x9a, 0xc9, 0x61, 0x69, 0x21, 0x87, 0xd3, 0x82, 0x99, 0x1c, 0x4e, 0xd5, 0xef, 0xc2, 0xd5, 0xf5,
	0x9b, 0xe3, 0x10, 0xe0, 0x70, 0xe6, 0x90, 0x2b, 0x70, 0xd0, 0xa9, 0x50, 0x2a, 0x78, 0x4b, 0xff,
	0x43, 0xf0, 0x7e, 0xf0, 0x56, 0xc5, 0x46, 0xfd, 0x56, 0x8a, 0x5a, 0x29, 0x8b, 0xca, 0x4f, 0x53,
	0x51, 0x29, 0xa6, 0xdc, 0xd2, 0x78, 0xfc, 0x3f, 0x17, 0x65, 0x74, 0x1f, 0xd6, 0x26, 0x9e, 0x7b,
	0x32, 0x66, 0x15, 0x68, 0xb1, 0x05, 0x35, 0x22, 0x1e, 0x2b, 0x55, 0x3d, 0x4b, 0xfd, 0x34, 0x5b,
	0xc0, 0xa3, 0xff, 0x5d, 0xad, 0xaf, 0x19, 0x9a, 0x2c, 0xa1, 0x0a, 0x14, 0xdb, 0xdd, 0xa8, 0x98,
	0x56, 0xa1, 0x74, 0xd8, 0xeb, 0xf7, 0xe5, 0xa2, 0xfa, 0x14, 0xae, 0xe5, 0x44, 0x65, 0x5e, 0x96,
	0x49, 0x39, 0x59, 0xa6, 0xfe, 0xba, 0x04, 0x0d, 0x51, 0x7f, 0xc1, 0x1d, 0x52, 0xbe, 0x3b, 0xee,
	0xc3, 0x9a, 0x83, 0x4d, 0x0b, 0x07, 0xe3, 0xa8, 0x6a, 0x2d, 0x8e, 0x18, 0x0d, 0xc6, 0x8b, 0x80,
	0xee, 0x59, 0xe8, 0x09, 0xac, 0x46, 0x42, 0xcc, 0x71, 0xf5, 0x5d, 0x75, 0x49, 0x3a, 0xd1, 0xb8,
	0x08, 0x35, 0x97, 0x04, 0x97, 0x3a, 0x53, 0x40, 0xcf, 0xa1, 0xa1, 0xbf, 0xe8, 0xb4, 0x59, 0x5a,
	0xe2, 0x28, 0x96, 0x22, 0x03, 0x1f, 0x2d, 0x33, 0x20, 0xca, 0x32, 0x3b, 0x29, 0x75, 0xf4, 0x03,
	0x96, 0xd7, 0x98, 0xfa, 0x3f, 0x5d, 0xb2, 0x52, 0x76, 0xe8, 0xaf, 0x98, 0xd6, 0x18, 0x3d, 0x82,
	0x6b, 0x11, 0x4e, 0xf6, 0x69, 0x82, 0xa2, 0x6b, 0xe1, 0x5f, 0xd0, 0x02, 0x11, 0x1f, 0x7a, 0x83,
	0x09, 0x70, 0x28, 0x23, 0xf6, 0x66, 0x17, 0x60, 0x7e, 0xa8, 0xf9, 0x00, 0x34, 0xd7, 0x59, 0x1c,
	0x80, 0xa4, 0x85, 0x01, 0xe8, 0xb3, 0xc2, 0x13, 0x69, 0xf3, 0x10, 0x36, 0x32, 0x27, 0xfb, 0x6f,
	0x8d, 0xa9, 0x2d, 0x58, 0x65, 0x30, 0xc7, 0x39, 0xb5, 0x0e, 0xf5, 0xa3, 0x41, 0xfb, 0x65, 0xbb,
	0xd7, 0x6f, 0xef, 0xf5, 0x35, 0x59, 0x52, 0xff, 0x5e, 0x80, 0x3a, 0x77, 0x07, 0xed, 0x44, 0x6f,
	0x15, 0x0f, 0xb7, 0xa1, 0x32, 0x0f, 0x84, 0xb9, 0x44, 0xd9, 0x65, 0x21, 0x70, 0x17, 0x6a, 0x76,
	0x38, 0x66, 0x51, 0x41, 0x4b, 0x48, 0x3c, 0x58, 0x55, 0xed, 0xb0, 0x4f, 0xa9, 0xe8, 0x71, 0x1c,
	0x25, 0x0c, 0xe4, 0xbb, 0x59, 0x70, 0xa2, 0xdd, 0xe4, 0x04, 0xc9, 0x12, 0x68, 0x56, 0xdf, 0x08,
	0x0d, 0xba, 0x07, 0x60, 0xbb, 0x13, 0x6f, 0xea, 0x3b, 0x98, 0xe0, 0xd4, 0xac, 0x27, 0xd0, 0xa3,
	0x4e, 0xe1, 0x63, 0xd7, 0xb2, 0xdd, 0x53, 0xa5, 0x22, 0x88, 0xc4, 0xc4, 0x77, 0x03, 0xb0, 0xfa,
	0x1c, 0x2a, 0x7d, 0xef, 0xf4, 0x5d, 0x39, 0x5b, 0x7d, 0x06, 0x4d, 0x31, 0x9c, 0x43, 0xf4, 0x18,
	0x60, 0x92, 0x14, 0x59, 0x3e, 0xb2, 0xdf, 0x5a, 0xd6, 0xd4, 0x04, 0x51, 0xf5, 0x9f, 0x05, 0x68,
	0x88, 0x93, 0x0a, 0xfa, 0x2e, 0x34, 0x02, 0xf3, 0x84, 0x8c, 0xe3, 0xf6, 0x29, 0x0e, 0xf3, 0xf5,
	0x88, 0xc3, 0xa3, 0x14, 0x7d, 0x0e, 0x8d, 0xe4, 0x1c, 0xd1, 0x04, 0xc4, 0xfa, 0xcc, 0xcd, 0x7c,
	0x50, 0x63, 0x03, 0x13, 0x21, 0xea, 0x72, 0xca, 0x57, 0x31, 0x6f, 0x48, 0xb8, 0x0b, 0x35, 0xc7,
	0x0c, 0xc9, 0x38, 0x33, 0xff, 0x57, 0x23, 0xb2, 0x11, 0xdd, 0x01, 0x76, 0x01, 0xf9, 0x8e, 0x77,
	0x4a, 0x37, 0x32, 0xb6, 0xdd, 0x89, 0x33, 0xb3, 0x30, 0xab, 0xc1, 0x31, 0x9e, 0x72, 0xc4, 0x8f,
	0x96, 0xed, 0x71, 0x2e, 0xfa, 0x1e, 0xd4, 0x12, 0x1d, 0xa5, 0x9c, 0x69, 0x92, 0x1c, 0xae, 0x78,
	0xa9, 0x58, 0x1d, 0xbd, 0x9f, 0x5c, 0xe4, 0x2a, 0x02, 0xd4, 0xf1, 0x75, 0xee, 0x1e, 0xc0, 0x3c,
	0x91, 0x95, 0xaa, 0x20, 0x21, 0xd0, 0xd5, 0x29, 0xa0, 0xd8, 0xe7, 0xc2, 0xa5, 0xeb, 0xe9, 0x15,
	0x18, 0xe6, 0x0c, 0x94, 0x82, 0x42, 0x72, 0x43, 0x2a, 0x2c, 0xde, 0x90, 0xd4, 0xdf, 0x49, 0x70,
	0xa3, 0xb3, 0x98, 0x1e, 0xd4, 0xb5, 0x07, 0x50, 0xa1, 0xa9, 0x84, 0xe3, 0x6b, 0xde, 0x27, 0x22,
	0x7c, 0x79, 0x2a, 0x3b, 0x3d, 0x26, 0xcf, 0xf2, 0x33, 0xd6, 0xde, 0xdc, 0x87, 0x86, 0xc8, 0x78,
	0xbb, 0x3c, 0x29, 0x65, 0xf3, 0xe4, 0x87, 0xb0, 0xd6, 0xc5, 0xbe, 0xe3, 0x5d, 0x4e, 0xb1, 0xcb,
	0xe2, 0xf1, 0x23, 0x68, 0x5a, 0x09, 0x65, 0x31, 0x63, 0x1a, 0x73, 0x56, 0xcf, 0x52, 0x2b, 0xb0,
	0xaa, 0x4d, 0x7d, 0x72, 0xa9, 0xfe, 0xab, 0x00, 0xeb, 0x0b, 0x23, 0x08, 0x7a, 0xb8, 0x70, 0x8d,
	0x40, 0xd9, 0xb9, 0x61, 0xe1, 0x1e, 0xd1, 0x82, 0x06, 0xcf, 0x41, 0x71, 0x82, 0x05, 0x96, 0x82,
	0x3c, 0x32, 0x1b, 0x3c, 0x4d, 0xe6, 0xe1, 0x5b, 0xd3, 0xeb, 0x9c, 0x46, 0x45, 0x1e, 0xc1, 0x35,
	0x76, 0x33, 0x25, 0xb6, 0x49, 0x70, 0xd2, 0x4a, 0xc5, 0x30, 0xde, 0x10, 0x04, 0x78, 0x3f, 0x5d,
	0x4c, 0x42, 0x71, 0x86, 0x4d, 0x25, 0xa1, 0x02, 0xa5, 0x9f, 0x79, 0xb6, 0x9b, 0xaa, 0x6e, 0x94,
	0x12, 0xd5, 0xb5, 0x00, 0x87, 0xc4, 0x0b, 0x70, 0xba, 0xae, 0x71, 0x62, 0x6a, 0xa6, 0xa9, 0xe6,
	0xcd, 0x34, 0xd1, 0xbd, 0x8b, 0x46, 0x80, 0x52, 0xcb, 0xde, 0xbb, 0x28, 0x23, 0xf1, 0x17, 0xfd,
	0x52, 0xbf, 0x86, 0xf7, 0x96, 0xce, 0x7d, 0xe8, 0x47, 0xc2, 0xbc, 0xc8, 0x42, 0x6d, 0x73, 0xf9,
	0xbc, 0x98, 0x99, 0x12, 0x8f, 0xe0, 0x7a, 0x97, 0x09, 0xb3, 0x95, 0x63, 0x50, 0x85, 0x32, 0x29,
	0xe5, 0xf4, 0x24, 0xe1, 0x16, 0x50, 0xc8, 0xb9, 0x05, 0xa8, 0xff, 0x2e, 0x41, 0x99, 0x19, 0x44,
	0x1f, 0x42, 0x5d, 0xe3, 0x7b, 0xd5, 0x0d, 0x23, 0x15, 0xb8, 0x22, 0x03, 0x6d, 0x43, 0xe3, 0x19,
	0x36, 0x03, 0x72, 0x8c, 0x4d, 0x12, 0x09, 0xa6, 0x66, 0x22, 0x91, 0x13, 0x59, 0xec, 0x9c, 0xe1,
	0xc9, 0xf9, 0x97, 0x33, 0x2f, 0x98, 0x4d, 0x53, 0xc5, 0x48, 0x64, 0xa0, 0x47, 0x80, 0x3a, 0xde,
	0xd4, 0x37, 0xe9, 0x12, 0xc3, 0x0b, 0x1c, 0x9c, 0x61, 0xd3, 0x4a, 0x8d, 0x1d, 0x39, 0x7c, 0xb4,
	0x03, 0xeb, 0x23, 0xd7, 0xf4, 0xc3, 0x33, 0x8f, 0x44, 0x19, 0x67, 0xe3, 0x90, 0xc2, 0x1c, 0xab,
	0x2c, 0x32, 0xd1, 0x13, 0xb8, 0xae, 0x9b, 0x27, 0x84, 0x97, 0xe4, 0xf9, 0xbc, 0x25, 0x42, 0x9f,
	0x2b, 0x81, 0x3e, 0x86, 0x35, 0xee, 0xfb, 0xb8, 0xac, 0xd5, 0x04, 0x9d, 0x05, 0x1e, 0xba, 0x0f,
	0x4d, 0x4e, 0xa1, 0xa1, 0xdc, 0x55, 0x40, 0x7c, 0x8b, 0x49, 0xb1, 0xd0, 0x17, 0xa0, 0x08, 0x84,
	0x08, 0xff, 0xae, 0x1d, 0xe0, 0x09, 0xf1, 0x82, 0x4b, 0xa5, 0x2e, 0xac, 0xb1, 0x54, 0x0a, 0x7d,
	0x1f, 0xae, 0x71, 0xde, 0xab, 0x76, 0x7f, 0xae, 0xdc, 0x10, 0x94, 0xf3, 0x04, 0x90, 0x0a, 0xb5,
	0xe7, 0x33, 0x32, 0x33, 0x1d, 0xa3, 0x3f, 0x52, 0x9a, 0xe2, 0x2b, 0x50, 0x42, 0x8e, 0x0a, 0x7d,
	0xa7, 0xbd, 0x6f, 0x3b, 0x58, 0x59, 0x13, 0x0b, 0x3d, 0xa3, 0xa1, 0x16, 0x54, 0x3b, 0x38, 0x20,
	0x94, 0xbf, 0x2e, 0xf0, 0x13, 0x6a, 0x14, 0x7c, 0x87, 0xf8, 0x92, 0x0a, 0xc8, 0x62, 0xf0, 0x71,
	0xe2, 0xee, 0x1f, 0xca, 0x50, 0xe1, 0x7b, 0x43, 0x07, 0x20, 0xb7, 0x2d, 0x8b, 0x7f, 0x8d, 0x70,
	0x70, 0x81, 0x03, 0x74, 0x47, 0xc8, 0x8f, 0xbc, 0xe0, 0xdf, 0x94, 0x05, 0x01, 0x56, 0xf7, 0x56,
	0xd0, 0x4f, 0xe0, 0x9a, 0x8e, 0xa7, 0xde, 0x05, 0x7e, 0x07, 0xb6, 0xf6, 0x60, 0xe3, 0x00, 0x93,
	0x85, 0x72, 0x9c, 0x11, 0xdc, 0x7c, 0x4f, 0xb4, 0x9d, 0x12, 0x56, 0x57, 0xd0, 0x2b, 0xb8, 0x73,
	0x80, 0x49, 0xf2, 0xc0, 0x98, 0xd7, 0x83, 0xb2, 0x16, 0x5b, 0x57, 0x35, 0x21, 0x75, 0x05, 0xfd,
	0x14, 0x6e, 0xe9, 0xd8, 0xf7, 0x02, 0xd2, 0xbe, 0x30, 0x6d, 0xc7, 0x3c, 0x76, 0x70, 0x1c, 0x1d,
	0x68, 0x59, 0xcf, 0xdc, 0x7c, 0xab, 0x1b, 0x2a, 0x75, 0xe2, 0x8d, 0x03, 0x4c, 0x72, 0x3a, 0x74,
	0x76, 0xab, 0xb7, 0x73, 0x4c, 0xa6, 0x6c, 0x7d, 0x0e, 0xf5, 0xb9, 0x03, 0xc2, 0x1c, 0x0b, 0xef,
	0x67, 0x07, 0xa6, 0x94, 0x81, 0x1f, 0x43, 0x63, 0x34, 0x3b, 0x9e, 0xda, 0x84, 0xbf, 0x48, 0x66,
	0x9f, 0xbf, 0x52, 0x08, 0xa4, 0x5f, 0xf7, 0xd4, 0x15, 0xf4, 0x05, 0xac, 0x8f, 0x30, 0xd9, 0xf3,
	0x3c, 0x12, 0x92, 0xc0, 0xf4, 0x7d, 0x6c, 0x5d, 0x81, 0x61, 0xc6, 0xc2, 0x53, 0x80, 0x11, 0x26,
	0xf1, 0x43, 0x76, 0xba, 0x6f, 0x52, 0xda, 0x9b, 0xd5, 0x07, 0x20, 0xcf, 0x3d, 0xc0, 0xc7, 0xd5,
	0x2b, 0xde, 0x5b, 0x36, 0x95, 0x25, 0xfc, 0x50, 0x5d, 0xd9, 0x93, 0xbf, 0x79, 0xbd, 0x25, 0xfd,
	0xf9, 0xf5, 0x96, 0xf4, 0xd7, 0xd7, 0x5b, 0xd2, 0x6f, 0xfe, 0xb6, 0xb5, 0xf2, 0x9f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x33, 0x7b, 0x46, 0x6e, 0xb0, 0x17, 0x00, 0x00,
}
